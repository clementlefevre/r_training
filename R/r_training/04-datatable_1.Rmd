# Data manipulation - part 2

## First steps with data.table  {-}

The data.table syntax is as follow :

**`DT[     filtering_condition    ,    formula    ,   grouping_columns    ]`**

That's it. The next part of this lesson will show you how to use it.


First thing first, we load the necessary pacakges :

```{r}
library(openxlsx)
library(data.table)
```


We start by loading our Sales Files again :

```{r echo=FALSE, results='hide'}
# create a new 'data' folder to store the files :
dir.create(file.path("./data"), showWarnings = FALSE)

# download the samples files from the cloud :
download.file("https://r-training-bookdown.s3.amazonaws.com/data/Financial+sample.xlsx", "./data/Financial sample.xlsx", mode = "wb")


DT_sales <- read.xlsx("./data/Financial sample.xlsx", sheet = "Sales", detectDates = TRUE)
```
Nobody is perfect, especially Leandro from Accounting. Although you begged him to send you the List of the Customer Support Staff as an Excel file, he insists on sending it as a .csv file. Relax, take it easy™ :

```{r}
download.file("https://r-training-bookdown.s3.amazonaws.com/data/CustomerSupport.csv", "./data/CustomerSupport.csv", mode = "wb")
DT_customer_support <- fread("./data/CustomerSupport.csv")
```


And then, we use the `setDT` function to able to use data.table on our dataframes. Think of it like a magic incantation that unleash special skills  never seen on Linkedin.

```{r}
setDT(DT_sales)
setDT(DT_customer_support)
```


Time to use the data.table syntax. First with the **`filtering_condition`** :
Filter the dataframe on the "Carretera" **Product**  :
```{r  results='hide'}
DT_sales[Product == "Carretera"]
```

```{r echo=FALSE}
library(kableExtra)
kable(head(DT_sales[Product == "Carretera"])) %>%
  kable_styling() %>%
  scroll_box(width = "100%", box_css = "border: 0px;")
```


<br />
And now the second data.table part, the **`formula`**: 

We add a new column **"Profit.Margin"** = "Sale.Price" - "Manufacturing.Price" :*
```{r}
DT_sales[, Profit.Margin := (Sale.Price - Manufacturing.Price)]
```

*Note : see the comma* **`,`** *before `Profit.Margin` ? As we do not use any filter, we keep it empty.*
*We could also write `DT_sales[Product="Carretera",Profit.Margin:=(Sale.Price - Manufacturing.Price)]`, and this would have filtered the DT first before applying the formula. Try by yourself !*   

<br />
We now want to replace "United States of America" with "USA" in the country column :
```{r}
library(stringr) # Yes, this is a new package and Yes, you need it to replace text :
DT_sales[, Country := str_replace(Country, "United States of America", "USA")]
```
<br />
...    and we check the previous action was successful :
```{r}
unique(DT_sales$Country)
```




<br />
Select three columns : "Product", "Country", "Profit.Margin" and copy the result in a new dataframe :
```{r results='hide'}
DT_sales_light <- DT_sales[, c("Product", "Country", "Profit.Margin")]
head(DT_sales_light)
```


```{r echo=FALSE}
library(kableExtra)
kable(head(DT_sales_light[Product == "Carretera"])) %>%
  kable_styling() %>%
  scroll_box(width = "100%", box_css = "border: 0px;")
```



#### Quizz {-}

Download the  [**Financial+sample.xlsx** Excel file](https://r-training-bookdown.s3.amazonaws.com/data/Financial+sample.xlsx) and copy it in your RStudio project.
Load this file `openxlsx` into a Dataframe.


<div id="main_Quizz" tabindex=-1>
<div id="Quizz_A1" ></div>
<div id="Answer_A1" class="toggle"><p id="p_Answer_A1">.</p>
```{r eval=TRUE}
    max(mtcars$mpg)
```
</div>
******

<div id="Quizz_A2" ></div>
<div id="Answer_A2" class="toggle"><p id="p_Answer_A2">.</p>
```{r eval=FALSE}
    setdiff(mtcars, mtcars) %>% nrow()
```
</div>
</div>



```{r echo=FALSE}
htmltools::tags$script(src = "https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js")
htmltools::tags$script(src = "quizz.json")
htmltools::tags$script(src = "quizz.js")
```

  
  
  
### Pivot table in R  {-}
The R equivalent of the Excel Pivot Table is the group operation.

We want to count the **number of Product categories per Country** :

```{r}
DT_sales[, .(count_Products = uniqueN(Product)), by = .(Country)]
```

<br />
Create a pivot table with the **total number of units sold** per **Product** :

```{r}
DT_sales[, .(total_units_sold = sum(Units.Sold)), by = .(Product)]
```

Neat isn't it ?

<br />
But your Boss© want those results sorted per value. No big deal here :
```{r}
DT_sales[, .(total_units_sold = sum(Units.Sold)), by = .(Product)][order(total_units_sold)]
```
<br />
But your Boss© want those results sorted per value, in the descending order :

```{r}
DT_sales[, .(total_units_sold = sum(Units.Sold)), by = .(Product)][order(-total_units_sold)]
```
<br />
How about grouping the data on multiple columns ? Like per **Product** and **Country** ?
```{r}
DT_sales[, .(total_units_sold = sum(Units.Sold)), by = .(Product, Country)] %>% head()
```
<br />
How about grouping the data on multiple columns ? Like by **Product** and **Country** ? With two grouping variables ?
```{r}
DT_sales[, .(total_units_sold = sum(Units.Sold), median_units_sold = median(Units.Sold)),
  by = .(Product, Country)
] %>% head()
```

<br />

Your Sales team only needs the **Top 2 Selling Countries per Product** :

For this, we first copy the grouped dataframe in a new variable `DT_grouped` :
```{r}
DT_grouped <- DT_sales[, .(total_units_sold = sum(Units.Sold)), by = .(Product, Country)]
DT_grouped[, head(.SD, 2), by = .(Product)]
```
<br>

Your Sales team only needs the **Worst 2 Selling Countries per Product** :
```{r}
DT_grouped[, tail(.SD, 2), by = .(Product)]
```
<br>

Your Sales team finally made its mind : it needs the **Top 2 Selling Countries per Product** AND the **Worst 2 Selling Countries per Product**^[Leandro has nothing to do with this] :

```{r}
DT_top_2 <- DT_grouped[, head(.SD, 2), by = .(Product)]
DT_top_2[, category := "TOP"]

DT_worst_2 <- DT_grouped[, tail(.SD, 2), by = .(Product)]
DT_worst_2[, category := "WORST"]

DT_top_worst_2 <- rbindlist(list(DT_top_2, DT_worst_2)) # rbindlist will concatenate the two table.

DT_top_worst_2
```




### Merge, the VLOOKUP variant in R {-}

One common operation in Excel is to combine two tables, with the `VLOOKUP` (or `XLOOKUP`) formula.

You can very easily do the same in R.
Remember the **`CustomerSupport.csv`** file provided by Leandro ? 
Let's say we want to add the Name of the Customer Support person to the previous Top/Worst Table.
To combine both `DT_top_worst_2` and `DT_customer_support`, we use the **merge** function :
```{r}
DT_top_worst_2_with_customer_support <- merge(DT_top_worst_2, DT_customer_support, by = c("Product", "Country"), all.x = TRUE)
```

Check the content of the newly created `DT_top_worst_2_with_customer_support` dataframe.

Alleluia, we now have a new column `Sales.Person`.

But, but wait... for "USA" the names of the `Sales.Person` are missing.

Before you send an angry email to Leandro's boss, remember where the "USA" value comes from ? Indeed, we replaced "United States of America" with "USA" in the `DT_sales` dataframe (from which the `DT_top_worst_2` is based on)^[Leandro has nothing to do with this].


Relax, take it easy. What we have to do, yes you guessed correctly, is to adjust the *Country* column in the `DT_customer_support` dataframe :
```{r}
DT_customer_support[, Country := str_replace(Country, "United States of America", "USA")]
```


And now we are good to merge :
```{r tidy = FALSE}
DT_top_worst_2_with_customer_support <- merge(DT_top_worst_2, DT_customer_support,
  by = c("Product", "Country"),
  all.x = TRUE
)
```


Some more explanations regarding the **merge** operation :

- **merge** takes the following parameters : `merge(the_first_dataframe,  the_second_dataframe, by=c("the_first_column_to_match_on","the_second_column_to_match_on"))`
- you can only merge two dataframe at the time. you can use as many matching columns as you want.
- we added the `all.x=TRUE` option to make sure that all rows of the first dataframe are kept, even if there was not match with the second dataframe.

But how to merge two dataframes when the column names do not match ?


Relax, take it easy. In this case, let's imagine Leandro's `DT_customer_support` dataframe has  **"country_sales"** instead of **"Country"** for column. To merge with our `DT_top_worst_2`, we would then write :
```{r tidy = FALSE, eval=FALSE}
DT_top_worst_2_with_customer_support <- merge(DT_top_worst_2, DT_customer_support,
  by.x = c("Product", "Country"),
  by.y = c("Product", "country_sales"),
  all.x = TRUE
)
```


### Export the result to Excel  {-}

And finally, the last step : export your dataframe in to an Excel file :
```{r}
write.xlsx(DT_top_worst_2_with_customer_support, "./data/DT_top_worst_2_with_customer_support.xlsx", sheetName = "grouped Sales")
```


To download this file, just check the box besides the filename `DT_top_worst_2_with_customer_support.xlsx` in the file explorer (bottom right) and `More` -> `export`.

### Send the result to Leandro {-}

* Note : this only works if you are using the Desktop Version of RStudio (e.g not the RStudio Cloud). For more info on how to install R and RStudio desktop see [here]

### Exercice  {-}
The **`Financial sample.xlsx`** file in the data folder contains 2 sheets : "Sales" & "Managers".

- Load the "Managers" sheet into adataframe named `DT_managers`,
- Compute the total sales per Year and per Product,
- merge the resulting dataframe with the `DT_managers` dataframe,
- save it as `DT_yearly_sales_per_manager.xlsx`







```{r}
# i help you here : 
DT_managers <- read.xlsx("./data/Financial sample.xlsx", sheet = "Managers", detectDates = TRUE)
```

### Useful resources to learn data.table : {-}

- https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html
- https://franknarf1.github.io/r-tutorial/_book/tables.html#tables
